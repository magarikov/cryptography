from time import *
from random import *
import math


def nod(a, b):
    # проверяем входные данные
    if (a <= 0) or (b <= 0):
        print("numbers must be greater than zero")
    
    if (b > a): 
        a, b = b, a

    # устанавливаем начальные значения
    
    x = [0 for i in range(1000)]
    x[0] = 1
    x[1] = 0
    y = [0 for i in range(1000)]
    y[0] = 0
    y[1] = 1
    
    r = [] 
    q = []
    i = 0

    while (b != 0):
        # усеченное частное
        q.append((a + b // 2) // b)

        r.append(a - q[i] * b)
        a, b = b, r[i]

        x[i + 1], x[i + 2] = x[i + 1], x[i] - q[i] * x[i + 1]
        y[i + 1], y[i + 2] = y[i + 1], y[i] - q[i] * y[i + 1]
        
        i += 1
    a = abs(a)
    return a



# Теорема ферма: a^p ≡ a (mod p), если p - простое
# Отсюда a^p-1 ≡ 1 (mod p), при условии НОД(a, p) == 1
# Если p - не простое, то сравнение a^p-1 ≡ 1 (mod p) будет выполняться только для очень редких a, 
# Часто будет что-то вроде a^p-1 ≡ 243 (mod p)
# 
# После k попыток вероятность ошибки - 1/2^k - назвать составное простым
# 1/2 т.к. доказано, что чисел а, дающих неверное представление о простоте числа n
# не больше половины чисел
# n - число на проверку, k - число итераций
def test_ferma(n, k):
    
    if (n < 5):
        print("Number must be greater than 5")
        return


    good_osnovanie = []
    good_ostatki = []

    flag = 1  #
    for i in range(k):

        a = randint(2, n - 2)

        # теорема ферма работает только для взаимно простых чисел (вообще из без этого норм работало)
        if nod(a, n) != 1:
            continue

        r = pow(a, n - 1, n)
        
        if r != 1:
            flag = 0
            break
        else:
            good_osnovanie.append(a)
            good_ostatki.append(r)
     
    if flag:
        print("Тест Ферма: ", n, " - вероятно простое")
        print("Основания, для которых условие простоты выполняется: ", good_osnovanie[0:5])
        print("Соответствующие остатки от делений ", good_ostatki[0:5])
    else: 
        print("Тест Ферма: ", n, " - составное")
        print("Основание для которого нарушается условие простоты: ", a)
        print("Нарушенное словие простоты: r != 1 - остаток не равен 1, нарушена теорема Ферма")

    print()

# Этот символ показывает, является ли a квадратичным вычетом по модулю n
# символ якоби (a/n) - оба числа могут быть составными - произведение
# символов лежандра, такое что (a/n) = (a/p1) * ... * (a/pk), где pi - простое 

# Алгоритм итеративно:
#Сводит a к a mod n.
#Убирает все степени 2 из a (пишем a = 2^k * a1).
#Вносит множитель от 2^k в знак s (формула через n % 8).
#Если a1 == 1 — возвращает накопленный знак.
#Применяет закон квадратичной реципроцности: меняем (a1/n) на (n mod a1)/a1, возможно меняя знак, 
# если оба ≡ 3 (mod 4).
#Повторяем.
#Если в какой-то момент a == 0 — возвращаем 0 (если n>1)
def yakobi(a, n):

    if (n < 3):
        print("n must be > 3")
    if (a < 0) or (a > n):
        print("a must be: 0 <= a <= n")

    # учитывает знак от (2/n):
    # = 1, n ≡ 1,7 (mod 8)
    # = -1, n ≡ 3,5 (mod 8)
    s = 0
    
    # 1
    # накопитель общего знака
    g = 1

    while (1):
        
        # 2-3
        if a == 0:
            return 0
        if a == 1:
            return g
        
        # 4
        k = 0
        while (a % 2 == 0):
            k += 1
            a = a // 2
        a1 = a

        # 5
        if k % 2 == 0:
            s = 1
        else:
            if (n % 8 == 1) or (n % 8 == 7):
                s = 1
            if (n % 8 == 3) or (n % 8 == 5):
                s = -1

        # 6
        if a1 == 1:
            return g * s
        
        # 7 
        if (n % 4 == 3) and (a1 % 4 == 3):
            s = -s
        
        # 8
        a = n % a1
        n = a1
        g = g * s


# уcловие простоты: для любого а выполняется
# a^((n-1)/2) ≡ (a/n) mod n, КРИТЕРИЙ ЭЙЛЕРА
# условие выполняется - остаток совпадает с якоби - вероятно простое
# нарушается - не совпадает с якоби - точно составное
def solovey(n, k):
    if (n < 5 or n % 2 == 0):
        print("Number must be >=5 and %2 == 1")
        return

    good_osnovanie = []
    good_ostatki = []
    a = 0
    flag = 1  #
    for i in range(k):

        a = randint(2, n - 2)

        r = pow(a, (n - 1) // 2, n)
        
        if (r != 1) and (r != n - 1):
            flag = -1
            break

        else:

            s = yakobi(a, n) % n
            if r != s:
                flag = 0
                break
            
            else:
                good_osnovanie.append(a)
                if (r == 1): good_ostatki.append(r) # 1
                else:  good_ostatki.append(n - r) # -1
    
    if flag == 1:
        print("Тест Соловэя-Штрассена: ", n, " - вероятно простое")
        print("Основания, для которых условие простоты выполняется: ", good_osnovanie[0:5])
        print("Соответствующие остатки от делений ", good_ostatki[0:5])
    elif flag == 0: 
        print("Тест Соловэя-Штрассена: ", n, " - составное")
        print("Основание для которого нарушается условие простоты: ", a)
        print("r != (a/n) - остаток не равен символу якоби")
    elif flag == -1:
        print("Тест Соловэя-Штрассена: ", n, " - составное")
        print("Основание для которого нарушается условие простоты: ", a)
        print("Нарушенное словие простоты: r != +-1 - остаток не равен +-1, нарушен критерий эйлера")
    
    print()


# O(k * (log n)^3)
def miller_rabin2(n, k):
    
    if (n < 5 or n % 2 == 0):
        print("n < 5 or n % 2 == 0")
    
    good_osnovanie = []
    good_ostatki = []
    a = 0

    # представляем n-1 как 2^s * r
    r = n - 1
    s = 0
    while r % 2 == 0:
        s += 1
        r = r // 2
    
    flag = 0
    for i in range(k):
        a = randint(2, n - 2)
        #  y ← a^r mod n
        y = pow(a, r, n)
        # Если y == 1, то вероятно простое
        # иначе проверяем цепочку квадратов (s):
        if (y != 1 and y != n - 1):
            j = 1
            # если первое не +-1, то где-то в середине должно появится -1, причем раньше 1
            while (j <= s - 1) and (y != n - 1):
                y = pow(y, 2, n)
                if y == 1:
                    flag = 1
                    break 
                j += 1
            if flag: break

            if y != n - 1:
                flag = 2
                break

        good_osnovanie.append(a)
        good_ostatki.append(y)

    if flag == 0:
        print(f"Тест Миллера-Рабина: число {n} - вероятно простое")
        print("Основания, для которых условие простоты выполняется: ", good_osnovanie[0:5])
        print("Соответствующие остатки от делений ", good_ostatki[0:5])

    if flag == 1:
        print(f"Тест Миллера-Рабина: число {n} - составное")
        print("Основание для которого нарушается условие простоты: ", a)
        print("Нарушенное словие простоты: y == 1")

    
    if flag == 2:
        print(f"Тест Миллера-Рабина: число {n} - составное")
        print("Основание для которого нарушается условие простоты: ", a)
        print("Нарушенное словие простоты: y == n - 1")

t1 = time()
test_ferma(66362118570275412275709433316356439068361677029889085093867106069737267959541693, 20)

solovey(66362118570275412275709433316356439068361677029889085093867106069737267959541693, 10)

miller_rabin2(66362118570275412275709433316356439068361677029889085093867106069737267959541693, 10)
t2 = time()
print(t2 - t1)